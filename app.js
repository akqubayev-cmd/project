// import { image_question, result } from './data.js';



const image_question=[[' Каковы основные причины необходимости параллельных и распределённых вычислений?', ' Сокращение времени, требуемого для решения задач с большим объёмом вычислений.', ' Увеличение скорости работы только однопроцессорных систем.', ' Решение задач, связанных только с обработкой изображений.', ' Повторение одних и тех же операций.', ' Ускорение разработки программного обеспечения.'],
[' Как классифицируются системы параллельных вычислений?', ' По типу и количеству процессоров, глобальному механизму управления и по синхронной/асинхронной работе.', ' Только по скорости процессоров.', ' По используемому программному обеспечению.', ' Только по размеру компьютеров.', ' По скорости передачи данных.'],
[' В чём разница между SIMD и MIMD?', ' SIMD управляет множеством данных одной командой, а MIMD управляет различными командами одновременно.', ' SIMD работает только с одним процессором, MIMD всегда с двумя процессорами.', ' MIMD всегда медленнее SIMD.', ' SIMD используется только в приложениях искусственного интеллекта.', ' MIMD никогда не выполняет команды одновременно.'],
[' Что такое синхронная работа в параллельных компьютерах?', ' Работа процессоров одновременно с общими глобальными тактовыми импульсами.', ' Только случайное распределение данных.', ' Каждый процессор выполняет разные операции в разное время.', ' Все процессоры работают независимо друг от друга.', ' Синхронизация используется только для замедления передачи данных.'],
[' Для чего используется DAG (ориентированный ациклический граф)?', ' Для отображения последовательности операций и зависимости данных в параллельных алгоритмах.', ' Используется только для задач обработки изображений.', ' Для измерения мощности процессоров.', ' Для вычислений на графах.', ' Для проверки сетевых подключений компьютеров.'],
[' Какова основная функция процессоров в системах параллельных вычислений?', ' Управление командами, которые будут выполняться другими процессорами.', ' Замедление передачи данных.', ' Используются только для обработки графики.', ' Всегда блокируют передачи данных.', ' Отключают соединение между различными процессорами.'],
[' Когда более подходящи процессорные массивы?', ' Для задач, разделённых по пространственным измерениям.', ' Только для программ малых масштабов.', ' Всегда для асинхронно работающих систем.', ' Для вычислений только на одном процессоре.', ' Только для локальной передачи данных.'],
[' Для каких задач используется технология СБМУ?', ' Для решения систем линейных уравнений и выполнения быстрого преобразования Фурье.', ' Используется только для обработки текста.', ' Для оптимизации только однокомпьютерных систем.', ' Только для передачи данных в локальных сетях.', ' Для обработки музыкальных файлов.'],
[' Какова роль синхронизации при выполнении параллельных алгоритмов?', ' Для управления работой процессоров и облегчения выполнения алгоритма.', ' Используется для замедления передачи данных.', ' Для создания повторяющихся циклов.', ' Только для увеличения энергопотребления процессоров.', ' Для оптимизации графических интерфейсов.'],
[' Как осуществляется связь между процессорами в распределённых системах?', ' Процессоры взаимодействуют через промежуточную сеть, состоящую из каналов прямой связи.', ' Данные передаются только через локальную память.', ' Процессоры никогда не взаимодействуют друг с другом.', ' Данные передаются только с внешних дисков.', ' Всегда используются отдельные каналы связи.'],
[' Каковы особенности каналов связи в распределённых вычислительных системах?', ' Каналы связи могут быть непредсказуемыми и изменяться во время работы системы.', ' Каналы всегда стабильны и неизменны.', ' Вся связь осуществляется только через физические соединения.', ' Каналы связи ограничивают передачу данных.', ' Передают данные только в одном направлении.'],
[' В чём разница между процессорными массивами и многопроцессорными системами?', ' Процессорные массивы тесно связаны с соседними элементами, тогда как многопроцессорные системы слабо связаны.', ' Процессорные массивы используются только для обработки текста.', ' Многопроцессорные системы всегда работают только с одним процессором.', ' Функция процессорных массивов заключается только в хранении данных.', ' Многопроцессорные системы предназначены только для графических вычислений.'],
[' Какова основная цель создания систем параллельных вычислений?', ' Для совместного выполнения вычислительных задач.', ' Используются для хранения данных.', ' Применяются только для обработки изображений.', ' Для увеличения мощности однопроцессорных систем.', ' Для ускорения разработки программного обеспечения.'],
[' В чём заключается задача маршрутизации в сетях передачи данных?', ' Задача маршрутизации заключается в оптимизации путей передачи данных.', ' Используется для замедления скорости передачи данных.', ' Это алгоритм, который хранит данные в сети.', ' Применяется только в локальных сетях.', ' Маршрутизация — это просто изменение входных данных.'],
[' Какова роль каналов связи в промежуточных сетях?', ' Обеспечивают передачу данных между процессорами и управляют работой системы.', ' Выполняют только передачу изображений.', ' Обеспечивают хранение данных.', ' Поддерживают процессоры в состоянии индивидуальной связи.', ' Всегда повторно обрабатывают данные.'],
[' Какие существуют способы связи между процессорами?', ' Для межпроцессорной связи используются общая память или метод передачи сообщений.', ' Процессоры взаимодействуют друг с другом только через текстовые файлы.', ' Всегда сохраняются локальные данные.', ' Только каналы связи передают данные.', ' Процессоры поддерживают связь только в одном направлении.'],
[' Для каких целей используются тесно связанные параллельные вычислительные системы на базе СБМУ?', ' Для решения систем линейных уравнений со специальной структурой.', ' Только для разработки компьютерных игр.', ' Для задач обработки текста.', ' Для увеличения скорости локальной сетевой связи.', ' Только для выполнения простых вычислительных операций.'],
[' Почему важен дизайн промежуточной сети параллельных компьютеров?', ' Определяет эффективность и скорость межпроцессорной связи.', ' Только для разработки программного обеспечения.', ' Используется только для хранения данных в локальной памяти.', ' Разрывает связь многопроцессорных систем.', ' Обеспечивает синхронную работу.'],
[' Каковы преимущества использования ориентированных ациклических графов (DAG)?', ' Облегчают описание параллельных алгоритмов, показывая последовательность операций и зависимости данных.', ' Используются только в обработке изображений.', ' Обеспечивают хранение данных.', ' Применяются только в графических интерфейсах.', ' Увеличивают скорость передачи данных.'],
[' Для чего используется глобальный механизм управления в системах параллельных вычислений?', ' Для координации процессоров и управления выполнением алгоритмов.', ' Не используется для обеспечения синхронной работы.', ' Всегда работает асинхронно.', ' Используется только для локальной связи.', ' Для уменьшения передачи данных.'],
[' Для каких задач используются систолические массивы?  ', ' Для решения систем линейных уравнений со специальной структурой  ', ' Используются только для обработки текста  ', ' Для выполнения простых вычислительных операций  ', ' Обеспечивают сетевое соединение  ', ' Для разработки языков программирования  '],
[' Какие методы используются для связи между процессорами?  ', ' Общая память или метод передачи сообщений  ', ' Процессоры поддерживают связь без коммуникации  ', ' Только каналы связи хранят данные  ', ' Хранятся только локальные данные  ', ' Разные данные не передаются  '],
[' Как работают многопроцессорные системы?  ', ' Каждый процессор выполняет свою работу, одновременно сотрудничая с другими процессорами  ', ' Работает только один процессор  ', ' Данные обрабатываются только локально  ', ' Процессоры работают независимо  ', ' Передача данных никогда не осуществляется  '],
[' Для чего используется алгоритм DAG?  ', ' Для демонстрации некоторых ключевых аспектов параллельных вычислений  ', ' Используется только в графических интерфейсах  ', ' Применяется для обработки текста  ', ' Хранит данные в локальной памяти  ', ' Для уменьшения скорости передачи данных  '],
[' Каково применение гибридных конструкций в системах параллельных вычислений?  ', ' Обеспечивают сочетание различных подходов к вычислениям  ', ' Работают только с одним процессором  ', ' Хранят данные только в локальной памяти  ', ' Используются только для обработки изображений  ', ' Обеспечивают синхронную работу  '],
[' Почему топология распределённых систем является нерегулярной?  ', ' Структура некоторых систем определяется внешними факторами и не разрабатывается заранее  ', ' Все системы всегда разрабатываются регулярно  ', ' Поддерживают связь только с локальной памятью  ', ' Сетевые соединения всегда стабильны  ', ' Данные передаются только в одном направлении  '],
[' Как управляются задержки передачи данных?  ', ' Оптимизируются для сокращения времени передачи сообщений через сеть  ', ' Передача данных всегда осуществляется с одинаковой скоростью  ', ' Применяется для хранения локальных данных  ', ' Процессоры работают, не учитывая задержки  ', ' Задержки возникают только при хранении данных  '],
[' На основе каких параметров определяются уровни управления процессорами?  ', ' На основе степени их совместной работы и независимости  ', ' Связаны только с типом данных  ', ' Используются для быстрой передачи данных  ', ' Процессоры работают независимо  ', ' Мощность процессоров определяется только связью с локальной памятью  '],
[' Каково значение маршрутизации в промежуточных сетях?  ', ' Маршрутизация важна для предотвращения перегрузки некоторых путей и повышения эффективности передачи данных  ', ' Используется только для передачи локальных данных  ', ' Маршрутизация не изменяет никакие данные  ', ' Блокирует сетевое соединение  ', ' Пути всегда используются одинаково  '],
[' Как оценивается эффективность параллельных алгоритмов?  ', ' На основе времени выполнения и используемых ресурсов  ', ' Только по объёму локальной памяти  ', ' Только по скорости компьютеров  ', ' Основывается на хранении данных  ', ' Для обеспечения синхронной работы  '],
[' Как находится оптимальное решение в моделях параллельных вычислений?  ', ' Через DAG-алгоритмы и различные алгоритмические подходы  ', ' Используется только для компьютерных игр  ', ' Применяется для обработки локальных данных  ', ' Увеличивает скорость сетевых соединений  ', ' Используется только для обработки изображений  '],
[' Как определяются тип и количество процессоров в параллельных компьютерах?  ', ' В зависимости от сложности вычислительной задачи и требований параллельного алгоритма  ', ' Только на основе требований программного обеспечения  ', ' Основывается только на локальных сетях  ', ' На основе размера процессоров  ', ' Используется для приложений обработки текста  '],
[' В каких случаях системы MIMD более предпочтительны?  ', ' Для сложных и масштабных вычислений, требующих одновременного выполнения различных инструкций  ', ' Работают только с одним процессором  ', ' Применяются только для локальной обработки данных  ', ' Используются для очень простых операций  ', ' Блокируют сетевые соединения  '],
[' Как используется высокоскоростная шина для внутрикластерной связи?  ', ' Для быстрой и эффективной передачи данных между процессорами внутри кластера  ', ' Используется только для компьютерных игр  ', ' Основывается на хранении данных  ', ' Отключает процессорные соединения  ', ' Замедляет передачу данных  '],
[' Какие основные технологические факторы влияют на развитие распределённых систем?  ', ' Развитие технологий связи, увеличение скорости передачи данных и создание более мощных процессоров  ', ' Только для хранения локальных данных  ', ' Применяется для уменьшения передачи данных  ', ' Для развития компьютерных игр  ', ' Используется для отключения процессорных соединений  '],
[' На какие части делятся задержки в коммуникациях в параллельных и распределённых системах?  ', ' Время обработки сообщения, время ожидания в очереди, время передачи и время распространения  ', ' Только время обработки и время ожидания в очереди  ', ' Только время передачи и время распространения  ', ' Только приём данных  ', ' Только время ожидания в очереди  '],
[' Как выражается штраф за коммуникацию с помощью формулы?  ', ' GP = TroTAL / TcoM  ', ' GP = TcoM / TroTAL  ', ' GP = TroTAL + TcoM  ', ' GP = TroTAL – TcoM  ', ' GP = TcoM + TroTAL  '],
[' Что означает время обработки сообщения?  ', ' Время, необходимое для подготовки данных к передаче  ', ' Время, необходимое для приёма данных  ', ' Это только время ожидания в очереди  ', ' Время, необходимое для отправки пакетов  ', ' Это только время для соответствующей обработки  '],
[' Когда возникает время ожидания в очереди?  ', ' Когда пакеты данных стоят в очереди на отправку  ', ' Во время приёма данных  ', ' Только когда очередь пуста  ', ' Только когда данные обрабатываются  ', ' Когда пакет готов  '],
[' Что такое время передачи?  ', ' Время, необходимое для передачи всех битов пакета  ', ' Только время, необходимое для приёма пакетов  ', ' Время, необходимое для обработки данных  ', ' Это только время ожидания в очереди  ', ' Время, необходимое для подготовки пакетов  '],
[' Что включает в себя время распространения?  ', ' Время между передачей последнего бита пакета и его приёмом  ', ' Время ожидания на входе пакета  ', ' Время, обеспечивающее соответствующую обработку данных  ', ' Время, необходимое для приёма пакета  ', ' Это только время получения данных  '],
[' Что означает маршрутизация в каналах связи?  ', ' Направление пакетов по сети к месту назначения  ', ' Методы, используемые для приёма данных  ', ' Системы, обеспечивающие только обработку пакетов  ', ' Шифрование данных  ', ' Механизмы обнаружения ошибок  '],
[' Что показывает диаметр топологии сети?  ', ' Максимальное расстояние между любыми двумя узлами  ', ' Только расстояние между одним узлом  ', ' Расстояние, необходимое для передачи данных  ', ' Количество узлов  ', ' Количество соединений в сети  '],
[' Почему важна связность сети?  ', ' Для измерения минимального числа узлов или дуг, которые нужно удалить, чтобы разделить сеть  ', ' Только для отображения числа узлов  ', ' Для обеспечения передачи данных только по одному каналу  ', ' Для увеличения числа коммуникационных каналов  ', ' Как критерий размещения сети  '],
[' Что обеспечивают алгоритмы управления потоком?  ', ' Ожидание пакетов, пока ресурсы не станут доступны в точке назначения  ', ' Регулярную передачу данных  ', ' Обеспечивают только освобождение сети  ', ' Обнаружение ошибок  ', ' Обеспечивают отправку пакетов в правильной последовательности  '],
[' Почему важно, чтобы топология сети соответствовала широкому диапазону алгоритмов?  ', ' Чтобы обеспечить эффективное выполнение вычислительной задачи.  ', ' Только для хранения данных.  ', ' Для количества каналов связи.  ', ' Для увеличения мобилизуемых ресурсов.  ', ' Для сокращения времени вычислений.'],
[' Что такое одноузловая и многоузловая широковещательная передача?  ', ' Одноузловая широковещательная передача — это отправка сообщения от одного процессора всем остальным, а многоузловая — это отправка сообщений от всех узлов одновременно в один узел.  ', ' Передача только через один узел.  ', ' Отправка нескольких сообщений одновременно.  ', ' Обмен данными между различными узлами.  ', ' Отправка только одного сообщения между двумя узлами.'],
[' Как называется механизм, определяющий начало и конец пакетов в каналах связи?  ', ' Кадрирование.  ', ' Упорядочивание.  ', ' Управление.  ', ' Фильтрация.  ', ' Регулирование.'],
[' Каковы два основных компонента алгоритмов управления каналом передачи данных (DLC) в виртуальных битовых каналах?  ', ' Механизм распознавания начала и конца пакетов и механизм обнаружения ошибок.  ', ' Механизмы, обеспечивающие только передачу пакетов.  ', ' Компоненты, используемые для обработки данных.  ', ' Только управление каналами связи.  ', ' Система для хранения данных.'],
[' Какова основная цель алгоритмов маршрутизации?  ', ' Выбор путей с минимальной общей задержкой для каждого пакета.  ', ' Увеличение количества каналов связи.  ', ' Обеспечение хранения данных.  ', ' Обнаружение и исправление ошибок.  ', ' Выбор только одного маршрута.'],
[' Каков один из факторов, влияющих на задержки в коммуникации?  ', ' Алгоритмы, используемые для управления сетью.  ', ' Только увеличение количества каналов связи.  ', ' Скорость обработки данных.  ', ' Количество узлов.  ', ' Хранение данных.'],
[' Как измеряется пропускная способность каналов с пакетной передачей?  ', ' Максимальная скорость передачи битов через соответствующий канал.  ', ' Скорость обработки данных.  ', ' Количество пакетов.  ', ' Количество каналов связи.  ', ' Количество узлов.'],
[' В чем может заключаться одна из проблем передачи пакетов?  ', ' Ожидание доступности ресурсов в точке доставки пакета.  ', ' Передача данных только через один канал.  ', ' Потеря только одного пакета.  ', ' Необнаружение ошибок.  ', ' Невозможность своевременного приема пакетов.'],
[' Когда требуется повторная передача пакетов?  ', ' В случае неправильной передачи или потери пакетов.  ', ' Только для увеличения количества пакетов.  ', ' Когда линии связи свободны.  ', ' Только во время обработки.  ', ' При отправке в один узел.'],
[' Почему важно обнаружение ошибок при управлении каналами связи?  ', ' Для обеспечения точной передачи пакетов.  ', ' Только для хранения данных.  ', ' Для увеличения количества каналов связи.  ', ' Только для одного направления.  ', ' Для предотвращения распространения ошибочных сообщений.'],
[' Что означает связность узлов в топологиях сетей?  ', ' Сохранение связности сети при удалении узлов.  ', ' Связано только с количеством узлов.  ', ' Передача данных только в одном направлении.  ', ' Только количество соединений.  ', ' Полная независимость узлов.'],
[' Какие факторы связаны с пропускной способностью канала связи?  ', ' Служебные биты, управляющие пакеты и доступность ресурсов.  ', ' Только количество каналов связи.  ', ' Передача данных только через один канал.  ', ' Только количество узлов.  ', ' Увеличение числа пакетов.'],
[' Почему важна связность процессоров в топологии сети?  ', ' Для обеспечения надежности связи.  ', ' Только для увеличения ширины сети.  ', ' Для увеличения числа узлов.  ', ' Только для обеспечения независимой связи.  ', ' Для обеспечения хранения пакетов.'],
[' В чем недостаток использования виртуальных каналов в каналах связи?  ', ' Увеличение задержек и снижение скорости передачи данных.  ', ' Передача пакетов только по одному пути.  ', ' Только обеспечение обнаружения ошибок.  ', ' Передача данных только через один канал.  ', ' Связь только с одним узлом.'],
[' Как осуществляется параллельная передача сообщений в топологии сети?  ', ' Разделением сообщения на несколько пакетов и отправкой их параллельно.  ', ' Использованием только одного канала.  ', ' Направлением данных только в один узел.  ', ' Только последовательной передачей.  ', ' Отправкой с исправлением ошибок.'],
[' Почему анализ штрафов связи может быть затруднен?  ', ' Из-за использования виртуальных каналов и снижения скорости передачи данных.  ', ' Только с увеличением количества пакетов.  ', ' Из-за длительного времени обработки данных.  ', ' Из-за недостаточного количества каналов связи.  ', ' Из-за отсутствия обнаружения ошибок.'],
[' Что такое механизм обнаружения ошибок и повторной передачи пакетов?  ', ' Обнаружение ошибок.  ', ' Только управление каналами связи.  ', ' Прием пакетов.  ', ' Проверка целостности.  ', ' Механизм ожидания в очереди.'],
[' Какова основная цель одноузловой широковещательной передачи?  ', ' Отправка одного и того же пакета от одного процессора ко всем остальным.  ', ' Отправка данных только в один узел.  ', ' Данные, связанные только с одним узлом.  ', ' Обнаружение ошибок.  ', ' Только для одного типа пакетов.'],
[' Что такое многоузловая широковещательная передача?  ', ' Одновременная передача от всех узлов в один.  ', ' Данные, отправляемые только в один узел.  ', ' Связь только с одним узлом.  ', ' Соответствующая связь между всеми узлами.  ', ' Использование только одного канала.'],
[' Почему необходимо обнаружение ошибок при приеме пакетов?  ', ' Для правильного приема данных.  ', ' Только для увеличения количества пакетов.  ', ' Для управления каналами связи.  ', ' Для предотвращения ошибочной передачи.  ', ' Только для проверки соединений.'],
[' На каких факторах основаны алгоритмы маршрутизации?  ', ' Задержки, связанные с каждым соединением.  ', ' Только на количестве пакетов.  ', ' Количество узлов.  ', ' Обнаружение ошибок.  ', ' Только на количестве независимых маршрутов.'],
[' Что увеличивает эффективность широковещательной передачи в топологии сети?  ', ' Увеличивает скорость и надежность связи.  ', ' Только увеличивает количество узлов.  ', ' Увеличивает количество пакетов.  ', ' Только линии связи.  ', ' Хранение данных.'],
[' Когда требуется повторная передача пакетов?  ', ' В случае неправильной передачи или потери пакетов.  ', ' Только для увеличения количества пакетов.  ', ' Когда линии связи свободны.  ', ' Только во время обработки.  ', ' При отправке в один узел.'],
[' Когда задержка очереди становится важной в алгоритмах маршрутизации?  ', ' Когда в каналах имеется большой поток пакетов.  ', ' Только при использовании одного канала.  ', ' При приеме данных.  ', ' Только при потере пакетов.  ', ' Когда ошибки не обнаруживаются.'],
[' Что обозначает «Q» в уравнении задержки в пакетных каналах связи?  ', ' Время ожидания и задержки в очереди.  ', ' Количество пакетов.  ', ' Время, необходимое для обработки данных.  ', ' Время ожидания в канале связи.  ', ' Скорость передачи данных.'],
[' Как выражается система линейных уравнений?  ', ' Ax = b  ', ' Ax + b = 0  ', ' A + x = b  ', ' x = Ab  ', ' bAx = 0  '],
[' Когда прямые методы считаются предпочтительными?  ', ' Когда можно найти точное решение с ограниченным числом операций  ', ' Применяются только для малых систем  ', ' Когда итерационные методы не работают  ', ' Только если число переменных мало  ', ' Когда данные неполны  '],
[' Какова основная характеристика итерационных методов?  ', ' Они асимптотически приближаются к решению  ', ' Находят точное решение  ', ' Работают только с малыми системами  ', ' Обеспечивают быстрые результаты  ', ' Выполняются только один раз  '],
[' В каких случаях итерационные методы предпочтительнее прямых методов?  ', ' Когда n очень велико  ', ' Только для малых систем  ', ' Для одномерных задач  ', ' Для нелинейных задач  ', ' В случае постоянных матриц  '],
[' Какой метод требует меньше памяти, если матрица A разреженная?  ', ' Итерационные методы  ', ' Прямые методы  ', ' Элементарные методы  ', ' Аналитические методы  ', ' Численные методы  '],
[' Какими методами можно решить задачу нахождения обратной матрицы A?  ', ' Прямыми и итерационными методами  ', ' Только прямыми методами  ', ' Только итерационными методами  ', ' Элементарными методами  ', ' Только математическими методами  '],
[' С какой скоростью итерационные алгоритмы приближаются к решению?  ', ' Геометрической или в геометрической прогрессии  ', ' Арифметической скоростью  ', ' Экспоненциальной скоростью  ', ' Квадратичной скоростью  ', ' Логарифмической скоростью  '],
[' Как происходит обмен данными в модели синхронных вычислений?  ', ' Немедленно и без потерь времени  ', ' Медленно и последовательно  ', ' Только в одном направлении  ', ' В зависимости от количества процессоров  ', ' Без обмена данными  '],
[' Какое предположение делается при вычислении обратной треугольной матрицы?  ', ' aii ≠ 0 для всех i  ', ' aij = 0 для всех i  ', ' aii = 0 только для одного i  ', ' aij > 0 для всех j  ', ' aii < 0 ни для одного i  '],
[' С какой целью используется метод обратной подстановки для нижней треугольной матрицы?  ', ' Для решения системы линейных уравнений  ', ' Для создания итерационных алгоритмов  ', ' Для вычисления верхних треугольных матриц  ', ' Для нахождения диагоналей матрицы  ', ' Для простых математических операций  '],
[' Согласно лемме 1.1, как выражается A⁻¹?  ', ' A⁻¹ = (I + L + L² + ... + Lⁿ⁻¹)  ', ' A⁻¹ = L⁻¹  ', ' A⁻¹ = I - L  ', ' A⁻¹ = L  ', ' A⁻¹ = 2L  '],
[' Согласно уравнению (1.2), какое выражение верно?  ', ' A⁻¹ = (I + L² + L⁴ + ... + L^(2^rlog n - 1))  ', ' A⁻¹ = I + L  ', ' A⁻¹ = Lⁿ  ', ' A⁻¹ = J + L  ', ' A⁻¹ = L2r1ognl  '],
[' При каких условиях используется обратная подстановка для решения системы Ax = b?  ', ' Когда A — нижняя треугольная матрица  ', ' Когда A — верхняя треугольная матрица  ', ' Когда матрица квадратная  ', ' Когда прямые методы не работают  ', ' Только при итерационных методах  '],
[' Каково общее время выполнения с использованием n процессоров при обратной подстановке?  ', ' O(n)  ', ' O(log n)  ', ' O(n²)  ', ' O(n³)  ', ' O(log² n)  '],
[' Какова общая временная сложность последовательного алгоритма обратной подстановки?  ', ' O(n²)  ', ' O(log n)  ', ' O(n³)  ', ' O(n)  ', ' O(log² n)  '],
[' Какова временная сложность последовательных алгоритмов для решения задачи Ax = b?  ', ' O(n²)  ', ' O(log n)  ', ' O(n³)  ', ' O(n)  ', ' O(log² n)  '],
[' Как выражается эффективность параллельного алгоритма?  ', ' T*(n)/(pTp(n))  ', ' Tp(n)/T*(n)  ', ' pTp(n)/T*(n)  ', ' T*(n)/pTp(n)  ', ' p/(T*(n))  '],
[' Что можно сделать, чтобы уменьшить штраф за связь в архитектуре процессора?  ', ' Уменьшить количество процессоров  ', ' Оптимизировать данные  ', ' Применить итерационные методы  ', ' Увеличить скорость обработки данных  ', ' Использовать прямые методы  '],
[' Как работают любые два процессора в модели синхронных вычислений?  ', ' Немедленно обмениваются данными  ', ' Работают медленно и последовательно  ', ' Передают данные по одному  ', ' Не взаимодействуют  ', ' Работают только в одном направлении  '],
[' В каких архитектурах используется параллельная реализация метода обратной подстановки?  ', ' Линейные массивы и гиперкубы  ', ' Системы с перекрестными связями  ', ' Верхние треугольные матрицы  ', ' Системы с общей памятью  ', ' Итерационные модели  '],
[' Что означает штраф за связь в параллельных алгоритмах?  ', ' Затраты на передачу данных и задержки  ', ' Избыточное количество процессоров  ', ' Синхронная передача данных  ', ' Работа только одного процессора  ', ' Координация процессоров  '],
[' Какова основная цель метода блочной разбиения матриц?  ', ' Ускорить вычисления и сбалансировать нагрузку процессоров  ', ' Облегчить хранение данных  ', ' Обеспечить синхронную работу  ', ' Передача данных  ', ' Увеличить количество процессоров  '],
[' Как влияет стоимость связи на метод обратной подстановки?  ', ' Может привести к увеличению времени с постоянным коэффициентом  ', ' Оптимизирует работу процессоров  ', ' Ускоряет вычисления  ', ' Уменьшает количество процессоров  ', ' Увеличивает связи  '],
[' Когда параллельный алгоритм обратной подстановки является более практичным?  ', ' Когда количество процессоров ограничено  ', ' При больших объемах данных  ', ' Когда синхронная работа невозможна  ', ' Когда используются только прямые методы  ', ' При снижении скорости вычислений  '],
[' Каково основное преимущество метода обратной подстановки в параллельных алгоритмах?  ', ' Высокая эффективность и меньшие требования к связи  ', ' Применение только к малым системам  ', ' Отсутствие быстрых результатов  ', ' Большой объем занимаемой памяти  ', ' Ограниченность количеством процессоров  '],
[' Когда происходит обмен данными в модели синхронных вычислений?  ', ' Немедленно и без потерь времени  ', ' Медленно и последовательно  ', ' Только в одном направлении  ', ' В зависимости от количества процессоров  ', ' Без обмена данными  '],
[' Какой метод более эффективен для решения системы линейных уравнений?  ', ' Обратная подстановка  ', ' Итерационный метод  ', ' Прямой метод  ', ' Геометрический метод  ', ' Квадратичный метод  '],
[' Что обеспечивает метод «разделяй и властвуй», используемый в параллельных алгоритмах?  ', ' Делает процесс вычисления быстрее и эффективнее  ', ' Только увеличивает хранение данных  ', ' Уменьшает количество каналов связи  ', ' Ограничивает синхронную работу  ', ' Увеличивает количество процессоров  '],
[' Какой метод используется для нижних треугольных матриц?  ', ' Обратная подстановка  ', ' Итерационный метод  ', ' Метод верхней треугольной матрицы  ', ' Метод с перекрестной связью  ', ' Методы геометрической прогрессии  '],
[' Как оценивается эффективность метода обратной подстановки?  ', ' O(1)  ', ' O(n)  ', ' O(n²)  ', ' O(log n)  ', ' O(log² n)  '],
[' Для каких типов матриц метод обратной подстановки наиболее подходит?  ', ' Нижние треугольные матрицы  ', ' Верхние треугольные матрицы  ', ' Квадратные матрицы  ', ' Круговые матрицы  ', ' Симметричные матрицы  '],
[' Что является причиной штрафа за связь в модели синхронных вычислений?  ', ' Обмен данными между процессорами  ', ' Низкая скорость вычислений  ', ' Медленная обработка данных  ', ' Большое количество процессоров  ', ' Потери связи между процессорами  '],
[' Какой основной метод используется для вычисления обратной треугольной матрицы?  ', ' Обратная подстановка  ', ' Геометрическая прогрессия  ', ' Прямой метод  ', ' Система с перекрестной связью  ', ' Итерационный метод  '],
[' Какой метод наиболее эффективен для снижения штрафа за связь в архитектуре процессора?  ', ' Сократить количество процессоров  ', ' Увеличить хранение данных  ', ' Использовать только один процессор  ', ' Применить итерационные методы  ', ' Использовать прямые методы  '],
[' Какова основная цель метода блочного разбиения матриц?  ', ' Увеличить скорость вычислений и сбалансировать нагрузку процессоров  ', ' Облегчить хранение данных  ', ' Обеспечить синхронную работу  ', ' Передача данных  ', ' Увеличить количество процессоров  '],
[' Какой метод используется для решения системы линейных уравнений?  ', ' Обратная подстановка  ', ' Итерационный метод  ', ' Геометрический метод  ', ' Симметричный метод  ', ' Дифференциальный метод  '],
[' Какой алгоритм используется для решения системы линейных уравнений Ax = b?  ', ' Решение через приведение к треугольной форме  ', ' Вычисление обратной матрицы  ', ' Метод Гаусса-Зейделя  ', ' Метод Ньютона  ', ' Метод Рунге-Кутты  '],
[' С какой целью матрица приводится к треугольной форме?  ', ' Для упрощения обратной подстановки  ', ' Для увеличения плотности данных  ', ' Для уменьшения скорости вычислений  ', ' Для оптимизации работы процессоров  ', ' Для снижения затрат на передачу данных  '],
[' С какой целью используется алгоритм, предложенный Цански?  ', ' Для вычисления обратной матрицы за время O(log² n)  ', ' Для уменьшения количества процессоров  ', ' Для нахождения геометрической прогрессии  ', ' Для решения нелинейных уравнений  ', ' Для оптимизации диагональных матриц  '],
[' Для решения каких задач применяются параллельные прямые методы?  ', ' Для решения системы линейных уравнений  ', ' Для решения нелинейных уравнений  ', ' Для математической оптимизации  ', ' Для численного интегрирования  ', ' Для дифференциальных уравнений  '],
[' Для каких типов матриц применяется алгоритм обратной подстановки?  ', ' Нижние треугольные матрицы  ', ' Верхние треугольные матрицы  ', ' Квадратные матрицы  ', ' Круговые матрицы  ', ' Симметричные матрицы  '],
[' В каких случаях итерационные методы более эффективны?  ', ' Для разреженных матриц  ', ' Для плотных матриц  ', ' Только для квадратных матриц  ', ' Для геометрических матриц  ', ' Для последовательных матриц  '],
[' Какой метод позволяет вычислить обратную матрицу за время O(n²)?  ', ' Через обратную подстановку  ', ' Методом Ньютона  ', ' Итерационным методом  ', ' Для диагональных матриц  ', ' Через нелинейные алгоритмы  '],
[' Какова основная особенность алгоритма Якоби?  ', ' Содержит умножение матрицы на вектор на каждой итерации  ', ' Оба матрицы равны друг другу  ', ' Высокая скорость вычислений  ', ' Уменьшение перекрестных связей  ', ' Большое количество процессоров  '],
[' Для каких типов системы уравнений применяется метод Гаусса-Зейделя?  ', ' Система линейных уравнений  ', ' Система нелинейных уравнений  ', ' Алгебраические уравнения  ', ' Дифференциальные уравнения  ', ' Задачи математической оптимизации  '],
[' Для каких типов матриц используется формула итерации SOR?  ', ' Нижние треугольные матрицы  ', ' Симметричные матрицы  ', ' Квадратные матрицы  ', ' Верхние треугольные матрицы  ', ' Круговые матрицы  '],
[' Для каких типов задач применяется алгоритм RGS?  ', ' Математическая оптимизация  ', ' Нелинейные уравнения  ', ' Алгебраические уравнения  ', ' Синхронные вычисления  ', ' Диагонали матриц  '],
[' Какой параметр влияет на скорость сходимости в итерационных методах?  ', ' Количество итераций  ', ' Количество процессоров  ', ' Объем памяти  ', ' Время вычислений  ', ' Скорость передачи данных  '],
[' Какова формула итерации SOR?  ', ' (1 - -y)x(t) - -yD⁻¹ [Lx(t + 1) + Ux(t) - b]  ', ' x(t + 1) = Ax(t)  ', ' x(t + 1) = D⁻¹Bx(t)  ', ' x(t + 1) = Lx(t) + Ux(t)  ', ' x(t) = Ax + b  '],
[' Какое уравнение решается методом Ричардсона?  ', ' x(t + 1) = (I - -yA)x(t) + -yb  ', ' Ax = b  ', ' A + x = b  ', ' x(t) = Ab  ', ' bAx = 0  '],
[' Какой метод используется для вычисления обратной матрицы нижней треугольной матрицы?', ' Обратная подстановка  ', ' Итеративный метод  ', ' Метод Ньютона  ', ' Метод Гаусса-Зейделя  ', ' Диагональный алгоритм  '],
[' Какой параметр изменяется для увеличения скорости итераций алгоритма SOR?', ' Коэффициент релаксации  ', ' Количество итераций  ', ' Скорость вычислений  ', ' Количество процессоров  ', ' Канал передачи данных  '],
[' Какой метод используется для быстрого обращения матриц?', ' Алгоритм Цанки  ', ' Метод Якоби  ', ' Метод Гаусса-Зейделя  ', ' Метод Ньютона  ', ' Алгоритм Ричардсона  '],
[' В каких системах возникает проблема многоточечного распространения?', ' Архитектура передачи сообщений  ', ' Общая память  ', ' Алгебраические системы  ', ' Дифференциальные уравнения  ', ' Числовая интеграция  '],
[' Каковы условия сходимости итеративных методов?', ' Если они сходятся, приводят к желаемому решению  ', ' Только для линейных уравнений  ', ' В синхронных системах  ', ' Для нелинейных уравнений  ', ' В случаях с высокой скоростью вычислений  '],
[' Как матрично выражается алгоритм Якоби?', ' x(t + 1) = -D⁻¹B x(t) + D⁻¹b  ', ' Ax = b  ', ' A + x = b  ', ' x = Ab  ', ' D⁻¹B x(t)  '],
[' Каково представление матрицы для метода Гаусса-Зейделя?', ' A = L + D + U  ', ' A = I + L + U  ', ' A = D + L  ', ' A = U + L  ', ' A = D + I  '],
[' Из каких элементов состоит формула итерации SOR?', ' (1 - ωD⁻¹L) – I [(1 - ω)L - ωD⁻¹U]  ', ' Ax = b  ', ' A = L + U  ', ' X(t) = Ab  ', ' D = L + U  '],
[' Как выражается формула итерации метода Ричардсона?', ' X(t + 1) = (I - ωA)x(t) + ωb  ', ' Ax = b  ', ' A + x = b  ', ' X = Ab  ', ' bAx = 0  '],
[' Какой параметр используется для ускорения сходимости итерации в алгоритме SOR?', ' Коэффициент релаксации  ', ' Количество итераций  ', ' Скорость вычислений  ', ' Количество процессоров  ', ' Скорость передачи данных  '],
[' В каких случаях проблема многоточечного распространения решается более эффективно?', ' В гиперкубической архитектуре  ', ' В линейных массивах  ', ' В общих системах памяти  ', ' В разреженных матрицах  ', ' В нелинейных уравнениях  '],
[' Для каких проблем используются параллельные итеративные методы?', ' Для решения систем линейных уравнений  ', ' Для математической оптимизации  ', ' Для дифференциальных уравнений  ', ' Для алгебраических уравнений  ', ' Для симметричных матриц  '],
[' Для каких типов матриц наиболее подходит метод Якоби?', ' Диагонально доминирующие матрицы  ', ' Симметричные матрицы  ', ' Круговые матрицы  ', ' Верхние треугольные матрицы  ', ' Квадратные матрицы  '],
[' Какое время требуется для вычисления обратной матрицы по алгоритму Цанки?', ' O(log² n)  ', ' O(n²)  ', ' O(n³)  ', ' O(log n)  ', ' O(n)  '],
[' Какова основная цель алгоритма SOR?', ' Увеличение скорости итерации  ', ' Снижение затрат на передачу данных  ', ' Оптимизация работы процессоров  ', ' Снижение времени вычислений  ', ' Увеличение плотности данных  '],
[' В каких областях широко используется метод Ричардсона?', ' В математической оптимизации и решении нелинейных уравнений  ', ' В решении разреженных матриц  ', ' В вычислении верхних треугольных матриц  ', ' В решении алгебраических уравнений  ', ' В решении дифференциальных уравнений  '],
[' Какие свойства имеет метод Гаусса-Зейделя?', ' Итеративное последовательное приближение  ', ' Приближение по геометрической прогрессии  ', ' Вычисления в синхронном режиме  ', ' Экспоненциальная скорость приближения  ', ' Применение для квадратных матриц  '],
[' Какова основная формула итерации SOR?', ' X(t + 1) = (1 - ω)x(t) - ωD⁻¹ [Lx(t + 1) + Ux(t) – b]  ', ' Ax = b  ', ' A = D + L  ', ' X = Ab  ', ' D⁻¹B x(t)  '],
[' Каково основное различие между методами Гаусса-Зейделя и Якоби?', ' Гаусс-Зейдель работает последовательно, Якоби — параллельно  ', ' Гаусс-Зейдель работает параллельно, Якоби — последовательно  ', ' Оба метода работают последовательно  ', ' Оба метода применяются только для малых матриц  ', ' Число итераций для обоих методов одинаково  '],
[' В каких методах используется параллельное умножение матриц на векторы?', ' Методы Якоби, Гаусса и Ричардсона  ', ' Методы Ньютона и Гаусса-Зейделя  ', ' Итеративные и экспоненциальные методы  ', ' Методы SOR и RGS  ', ' Дифференциальные и алгебраические методы  '],
[' Какова основная характеристика итеративных методов для решения нелинейных задач?', ' Приближение к фиксированной точке  ', ' Медленная сходимость  ', ' Только для решения линейных уравнений  ', ' Только для задач оптимизации  ', ' Непредсказуемые результаты  '],
[' Каково основное определение итерации сжимаемости?', ' Итерация, сходящаяся к фиксированной точке  ', ' Итерация, не сходящаяся к множеству  ', ' Уменьшение переменных на каждой итерации  ', ' Только для решения линейных задач  ', ' Без какого-либо приближения  '],
[' Какой интервал охватывает параметр "a" в эффекте сжатия?', ' (0, 1)  ', ' (1, 2)  ', ' (-1, 0)  ', ' (2, 3)  ', ' (-2, -1)  '],
[' Каково основное отличие псевдосжимаемой итерации от сжимаемой?', ' Псевдосжимаемая итерация имеет более слабые условия  ', ' Псевдосжимаемая итерация не сходится к фиксированной точке  ', ' Сжимаемая итерация работает только для линейных уравнений  ', ' Псевдосжимаемая итерация всегда обеспечивает быструю сходимость  ', ' Модуль сжатия больше  '],
[' Что означает фиксированная точка в процессе итерации?', ' Точка, удовлетворяющая условию T(x*) = x*  ', ' Точка, в которой нет изменений  ', ' Точка, где T(x*) > x*  ', ' Точка, где T(x*) < x*  ', ' Точка, где T(x*) = 2x*  '],
[' Что включает в себя неограниченная оптимизация?  ', ' Минимизация функции затрат  ', ' Поиск максимального значения  ', ' Увеличение функции F(x)  ', ' Решение нелинейных уравнений  ', ' Поиск глобального максимума  '],
[' Когда используется вариационное неравенство?  ', ' В исследованиях равновесия теории игр  ', ' Только в инженерном дизайне  ', ' Только в линейном программировании  ', ' Для решения дифференциальных уравнений  ', ' Для статистического анализа  '],
[' В какой области в основном используется итерация псевдосжатия?  ', ' Для решения нелинейных уравнений  ', ' Для увеличения эффекта сжатия  ', ' Для различных методов оптимизации  ', ' Для анализа данных  ', ' Для экономического моделирования  '],
[' К какому уравнению относится задача минимизации функции затрат?  ', " v'F(x) = 0  ", " v'F(x) > 0  ", " v'F(x) < 0  ", " v'F(x) = 1  ", " v'F(x) ≠ 0  "],
[' Что означает изменение эффекта сжатия в зависимости от нормы?  ', ' В разных нормах может быть или не быть сжатие  ', ' Эффект сжатия одинаков во всех нормах  ', ' Сжатие возможно только в одной норме  ', ' Изменение нормы не влияет на сжатие  ', ' Сжатие происходит в соответствии с нормой  '],
[' Какие условия требуются в ограниченной оптимизации?  ', ' Множество X должно быть замкнуто и выпукло  ', ' Множество X должно быть пустым  ', ' Множество X должно быть не выпуклым  ', ' Множество X должно быть только математическим  ', ' Множество X должно быть открытым  '],
[' Каково значение выпуклой функции в оптимизации?  ', ' Обеспечение глобальной минимизации  ', ' Поиск максимального решения  ', ' Увеличение функции F  ', ' Применение двойного интегрирования  ', ' Поиск фиксированной точки  '],
[' Почему взвешенная максимальная норма важна при выборе нормы?  ', ' Для увеличения эффекта сжатия  ', ' Для увеличения псевдосжатия  ', ' Для расширения геометрического анализа  ', ' Для решения дифференциальных уравнений  ', ' Для оптимизации нелинейных уравнений  '],
[' Какой метод используется для увеличения сходимости итерационного процесса?  ', ' Коэффициент релаксации  ', ' Увеличение скорости вычислений  ', ' Только увеличение количества итераций  ', ' Изменение фиксированной точки  ', ' Изменение нормы  '],
[' Какой метод чаще всего используется в нелинейной оптимизации?  ', ' Метод градиентного спуска  ', ' Графический анализ  ', ' Численное интегрирование  ', ' Метод максимального правдоподобия  ', ' Статические аналитические методы  '],
[' Какой результат достигается при применении эффекта сжатия?  ', ' Поиск фиксированной точки  ', ' Возникновение нефиксированной точки  ', ' Минимизация затрат  ', ' Непосредственный поиск максимального решения  ', ' Увеличение выпуклой функции  '],
[' Какие области применения функционального анализа?  ', ' Математика и экономика  ', ' Социальные науки  ', ' Биология  ', ' Химический анализ  ', ' История  '],
[' Какова роль фиксированной точки в вариационном неравенстве?  ', ' Обеспечение равновесия в нелинейных уравнениях  ', ' Только для математической оптимизации  ', ' Обеспечение распространения данных  ', ' Простое вычисление интегральных значений  ', ' Не имеет никакого значения  '],
[' В какой области в основном применяется эффект сжатия?  ', ' Математические модели и оптимизация  ', ' Цифровая обработка изображений  ', ' Генетические анализы  ', ' Молекулярная биология  ', ' Анализ социальных сетей  '],
[' Какова основная особенность итерации псевдосжатия?  ', ' Наличие фиксированной точки  ', ' Постоянство итерации  ', ' Решение только линейных уравнений  ', ' Решение только нелинейных уравнений  ', ' Отсутствие условия непрерывности  '],
[' Что представляет собой множество "X" в оптимизации?  ', ' Возможное множество решений  ', ' Ограничения  ', ' Только линейные пространства  ', ' Предположения  ', ' Только максимальные решения  '],
[' В каком случае обеспечивается сходимость итерационных методов?  ', ' Когда значение функции затрат уменьшается  ', ' Когда приближаемся к максимальному решению  ', ' Только когда количество итераций увеличивается  ', ' Только при изменении нормы  ', ' Когда количество итераций остается постоянным  '],
[' Какой подход чаще всего используется в ограниченной оптимизации?  ', ' Ортогональная проекция  ', ' Предполагаемая точка  ', ' Анализ не выпуклых множеств  ', ' Только максимальные значения  ', ' Анализ двойного графа  '],
[' Что означает ортогональная проекция на множество "X"?  ', ' Поиск ближайшей точки по евклидовой норме  ', ' Не проецирование данных  ', ' Удаление от проекционных точек  ', ' Поиск максимальных значений  ', ' Построение вариационных неравенств  '],
[' Что указывает условие F(x) = 0?  ', ' Минимизацию функции затрат  ', ' Глобальное максимальное значение  ', ' Максимальные решения  ', ' Нелинейные функции  ', ' Интерактивные методы решения  '],
[' Каково значение нормы в итеративных методах?  ', ' Определение эффекта сжатия  ', ' Увеличение количества итераций  ', ' Ограниченная оптимизация  ', ' Разные выпуклые функции  ', ' Проекция данных  '],
[' Какое основное преимущество итерации псевдосжатия?  ', ' Работа при слабых условиях  ', ' Более быстрое получение результатов  ', ' Поиск максимальной точки  ', ' Применение нелинейной оптимизации  ', ' Работа с анализом данных  '],
[' В каких случаях применяются методы нелинейной оптимизации?  ', ' Для систем различных уравнений  ', ' Только для линейных уравнений  ', ' В симметричных функциях  ', ' При поиске фиксированных точек  ', ' Для максимальных решений  '],
[' Какая норма чаще всего используется в неограниченной оптимизации?  ', ' Взвешенная максимальная норма  ', ' Общая стандартная норма  ', ' Линейная норма  ', ' Ограниченная норма  ', ' Двойная норма  '],
[' Какова основная область применения вариационных неравенств?  ', ' Теория игр и исследования равновесия  ', ' Генетические анализы  ', ' Социальные науки  ', ' Дифференциальные уравнения  ', ' Биологическое моделирование  '],
[' К какой точке приближаются с помощью итерационных методов?  ', ' К фиксированной точке  ', ' К максимальной точке  ', ' К минимальной точке  ', ' К множеству общих решений  ', ' Только к глобальной точке  '],
[' Какова основная особенность ограниченной оптимизации?  ', ' Минимизация затрат в заданном множестве  ', ' Поиск различных максимальных значений  ', ' Расширение множества  ', ' Применение максимальной нормы  ', ' Приближение в любой точке  '],
[' В каком случае итерация сжатия является непрерывной?  ', ' Когда модуль находится в интервале (0, 1)  ', ' Когда нет фиксированной точки  ', ' Только в одном уравнении  ', ' В разных множествах  ', ' В отсутствии проекции  '],
[' Для чего используется ортогональная проекция?  ', ' Для поиска ближайшей точки в множестве X  ', ' Для расширения множества  ', ' Только для линейного программирования  ', ' Нелинейный анализ  ', ' Применение максимальной нормы  '],
[' Какое основное утверждение используется в ограниченной оптимизации?  ', ' Минимизация возможна, если множество X замкнуто и выпукло  ', ' Когда множество X открыто  ', ' Максимальное решение только в уравнениях  ', ' Минимизация возможна только при изменении нормы  ', ' Ортогональная проекция не требуется  '],
[' В каких случаях итеративные методы эффективны?  ', ' При решении нелинейных задач  ', ' Только для линейных уравнений  ', ' В простых интегральных задачах  ', ' При вычислении математических рядов  ', ' В анализе круговых матриц  '],
[' Каково основное определение итерации сжатия?  ', ' Итерация, приближающаяся к фиксированной точке  ', ' Итерация, не приближающаяся к множеству  ', ' Уменьшение переменных на каждой итерации  ', ' Только для решения линейных задач  ', ' Отсутствие приближения  '],
[' К какому интервалу относится параметр "a" в эффекте сжатия?  ', ' (0, 1)  ', ' (1, 2)  ', ' (-1, 0)  ', ' (2, 3)  ', ' (-2, -1)  '],
[' Каково основное отличие итерации псевдосжатия от итерации сжатия?  ', ' Псевдосжатие имеет более слабые условия  ', ' Псевдосжатие не приближается к фиксированной точке  ', ' Сжатие работает только для линейных уравнений  ', ' Псевдосжатие всегда обеспечивает быструю сходимость  ', ' Модуль сжатия больше  '],
[' Что означает фиксированная точка в процессе итерации?  ', ' Точка, удовлетворяющая условию T(x*) = x*  ', ' Точка, в которой нет изменений  ', ' Точка, где T(x*) > x*  ', ' Точка, где T(x*) < x*  ', ' Точка T(x*) = 2x*  '],
[' Что включает в себя неограниченная оптимизация?  ', ' Минимизация функции затрат  ', ' Поиск максимального значения  ', ' Увеличение функции F(x)  ', ' Решение нелинейных уравнений  ', ' Поиск глобального максимума  '],
[' Когда используется вариационное неравенство?  ', ' В исследованиях равновесия теории игр  ', ' Только в инженерном дизайне  ', ' Только в линейном программировании  ', ' Для решения дифференциальных уравнений  ', ' Для статистического анализа  '],
[' В какой области в основном используется итерация псевдосжатия?  ', ' Для решения нелинейных уравнений  ', ' Для увеличения эффекта сжатия  ', ' Для различных методов оптимизации  ', ' Для анализа данных  ', ' Для экономического моделирования  '],
[' К какому уравнению относится задача минимизации функции затрат?  ', " v'F(x) = 0  ", " v'F(x) > 0  ", " v'F(x) < 0  ", " v'F(x) = 1  ", " v'F(x) ≠ 0  "],
[' Что означает изменение эффекта сжатия в зависимости от нормы?  ', ' В разных нормах может быть или не быть сжатие  ', ' Эффект сжатия одинаков во всех нормах  ', ' Сжатие возможно только в одной норме  ', ' Изменение нормы не влияет на сжатие  ', ' Псевдосжатие происходит в соответствии с нормой  '],
[' Какие условия необходимы для ограниченной оптимизации?  ', ' Множество X должно быть замкнутым и выпуклым  ', ' Множество X должно быть пустым  ', ' Множество X должно быть невыпуклым  ', ' Множество X должно быть только математическим  ', ' Множество X должно быть открытым  '],
[' Каково значение выпуклой функции в оптимизации?  ', ' Обеспечение глобальной минимизации  ', ' Нахождение максимального решения  ', ' Увеличение функции F  ', ' Применение двойного интегрирования  ', ' Нахождение фиксированной точки  '],
[' Почему взвешенная максимальная норма важна при выборе нормы?  ', ' Для увеличения эффекта сжатия  ', ' Для увеличения псевдосжатия  ', ' Для расширения геометрического анализа  ', ' Для решения дифференциальных уравнений  ', ' Для оптимизации нелинейных уравнений  '],
[' Какой метод используется для повышения сходимости итерационного процесса?  ', ' Коэффициент релаксации  ', ' Увеличение скорости вычислений  ', ' Просто увеличение количества итераций  ', ' Изменение фиксированной точки  ', ' Изменение нормы  '],
[' Какой метод наиболее часто используется в нелинейной оптимизации?  ', ' Метод градиентного спуска  ', ' Графический анализ  ', ' Численное интегрирование  ', ' Метод максимального правдоподобия  ', ' Статические аналитические методы  '],
[' Какой результат достигается при применении эффекта сжатия?  ', ' Нахождение фиксированной точки  ', ' Появление нефиксированной точки  ', ' Минимизация затрат  ', ' Немедленное нахождение максимального решения  ', ' Увеличение выпуклой функции  '],
[' Каковы области применения функционального анализа?  ', ' Математика и экономика  ', ' Социальные науки  ', ' Биология  ', ' Химический анализ  ', ' История  '],
[' Какова роль фиксированной точки в вариационных неравенствах?  ', ' Обеспечение равновесия в нелинейных уравнениях  ', ' Только для математической оптимизации  ', ' Обеспечение распространения данных  ', ' Простой расчет интегральных значений  ', ' Не имеет никакого значения  '],
[' В какой области применяется эффект сжатия?  ', ' Математические модели и оптимизация  ', ' Обработка цифровых изображений  ', ' Генетические анализы  ', ' Молекулярная биология  ', ' Анализ социальных сетей  '],
[' Какова основная характеристика псевдосжатия?  ', ' Наличие фиксированной точки  ', ' Постоянство итерации  ', ' Решение только линейных уравнений  ', ' Решение только нелинейных уравнений  ', ' Отсутствие условия непрерывности  '],
[' Что представляет собой множество "X" в оптимизации?  ', ' Возможное множество решений  ', ' Ограничения  ', ' Только линейные пространства  ', ' Предположения  ', ' Только максимальные решения  '],
[' Когда обеспечивается сходимость методов итерации?  ', ' Когда значение функции затрат уменьшается  ', ' Когда приближается к максимальному решению  ', ' Только при увеличении количества итераций  ', ' Только при изменении нормы  ', ' Когда количество итераций остается постоянным  '],
[' Какой подход чаще всего используется в ограниченной оптимизации?  ', ' Ортогональная проекция  ', ' Предполагаемая точка  ', ' Анализ невыпуклого множества  ', ' Только максимальные значения  ', ' Анализ двойного графа  '],
[' Что представляет собой ортогональная проекция на множество "X"?  ', ' Нахождение ближайшей точки по евклидовой норме  ', ' Не проекция данных  ', ' Удаление от проекционных точек  ', ' Поиск максимальных значений  ', ' Установление вариационных неравенств  '],
[' Что указывает условие F(x) = 0?  ', ' Минимизацию функции затрат  ', ' Глобальный максимум  ', ' Максимальные решения  ', ' Невыпуклые функции  ', ' Интерактивные методы решения  '],
[' Каково значение нормы в итеративных методах?  ', ' Определение эффекта сжатия  ', ' Увеличение количества итераций  ', ' Ограниченная оптимизация  ', ' Разные выпуклые функции  ', ' Проекция данных  '],
[' Какое основное преимущество псевдосжатия?  ', ' Работа при слабых условиях  ', ' Более быстрые результаты  ', ' Нахождение максимальной точки  ', ' Применения нелинейной оптимизации  ', ' Работа с анализом данных  '],
[' В каких случаях применяются методы нелинейной оптимизации?  ', ' Для систем различных уравнений  ', ' Только для линейных уравнений  ', ' В симметричных функциях  ', ' При поиске фиксированных точек  ', ' Для максимальных решений  '],
[' Какая норма наиболее часто используется в неограниченной оптимизации?  ', ' Взвешенная максимальная норма  ', ' Общая стандартная норма  ', ' Линейная норма  ', ' Ограниченная норма  ', ' Двойная норма  '],
[' Какова основная область применения вариационного неравенства?  ', ' Теория игр и исследование равновесия  ', ' Генетические анализы  ', ' Социальные науки  ', ' Дифференциальные уравнения  ', ' Биологическое моделирование  '],
[' К какой точке стремятся итерационные методы?  ', ' К фиксированной точке  ', ' К максимальной точке  ', ' К минимальной точке  ', ' К множеству общих решений  ', ' Только к глобальной точке  '],
[' Какова основная особенность ограниченной оптимизации?  ', ' Минимизация затрат в заданном множестве  ', ' Нахождение различных максимальных значений  ', ' Расширение множества  ', ' Применение максимальной нормы  ', ' Приближение к любой точке  '],
[' Когда сжатие итерации является непрерывным?  ', ' Когда модуль находится в интервале (0,1)  ', ' Когда нет фиксированной точки  ', ' Только в одном уравнении  ', ' В различных множествах  ', ' При отсутствии проекции  '],
[' Какова цель использования ортогональной проекции?  ', ' Нахождение ближайшей точки в множестве X  ', ' Расширение множества  ', ' Только линейное программирование  ', ' Нелинейный анализ  ', ' Применение максимальной нормы  '],
[' Какое основное утверждение используется в ограниченной оптимизации?  ', ' Минимизация возможна, если множество X замкнуто и выпукло  ', ' Когда множество X открыто  ', ' Максимальные решения только в уравнениях  ', ' Минимизация возможна только при изменении нормы  ', ' Ортогональная проекция не требуется  '],
[' Через сколько итераций завершится алгоритм Беллмана-Форда?  ', ' После конечного k итераций  ', ' С бесконечными итерациями  ', ' Меняется на каждой итерации  ', ' Требуется только одна итерация  ', ' В неопределенной итерации  '],
[' Для решения какой задачи используется алгоритм Беллмана-Форда?  ', ' Нахождение самого короткого пути  ', ' Вычисление максимального цикла  ', ' Оптимизация отрицательных направлений  ', ' Нахождение циклов  ', ' Завершение графа  '],
[' В каких условиях алгоритм Дейкстры работает лучше всего?  ', ' При ненегативных длинах направлений  ', ' При наличии отрицательных циклов  ', ' В бесконечных циклах  ', ' В динамических графах  ', ' В неупорядоченных графах  '],
[' Что означает предположение о положительном цикле?  ', ' Длины циклов положительны  ', ' Длина циклов отрицательна  ', ' Длина циклов равна нулю  ', ' Циклы разъединены  ', ' Циклы имеют обратное направление  '],
[' Какой узел считается специальным узлом?  ', ' Узел 1  ', ' Последний узел  ', ' Средний узел  ', ' Начальная точка цикла  ', ' Узел с отрицательным циклом  '],
[' Чем определяется каждый направление (i, j)?  ', ' Скаляром aij  ', ' Вектором aij  ', ' Графом qij  ', ' Матрицей mij  ', ' Значением направления  '],
[' Когда завершится алгоритм Беллмана-Форда?  ', ' Когда расстояния для всех узлов стабилизируются  ', ' При бесконечных итерациях  ', ' При достижении целевой точки  ', ' Когда найден отрицательный цикл  ', ' При отсутствии данных  '],
[' Какова сложность метода Дейкстры?  ', ' O(IAI + n log n)  ', ' O(n^2)  ', ' O(n^3)  ', ' O(log n)  ', ' O(nm)  '],
[' На каких двух основных предположениях основывается алгоритм Беллмана-Форда?  ', ' Связность и предположение о положительном цикле  ', ' Отсутствие циклов и связь графа  ', ' Бесконечные циклы и параллельная обработка  ', ' Отрицательные циклы и отсутствие связи  ', ' Ненаправленный граф и одна итерация  '],
[' Как найти минимальную длину от одного узла к другому?  ', ' Суммой длин направлений  ', ' Максимальным расстоянием  ', ' Средней длиной  ', ' Разностью между узлами  ', ' Количеством циклов  '],
[' Что происходит согласно предположению связности?  ', ' Для каждой вершины существует путь к целевой точке  ', ' Все вершины не связаны  ', ' Возникает цикл между вершинами  ', ' Увеличивается количество путей  ', ' Процессор заполнен  '],
[' Как определяется самый короткий путь?  ', ' Суммой длин путей  ', ' Количеством вершин  ', ' Количеством циклов  ', ' Максимальным расстоянием  ', ' Разностью направлений  '],
[' Какой алгоритм решает задачу о самом коротком пути для всех пар?  ', ' Алгоритм Флойда-Уоршелла  ', ' Алгоритм Беллмана-Форда  ', ' Алгоритм Дейкстры  ', ' Динамическое программирование  ', ' Теория графов  '],
[' В каких системах алгоритм Беллмана-Форда более эффективен?  ', ' В распределенных системах  ', ' В одноядерных системах  ', ' В замкнутых системах  ', ' В аналоговых системах  ', ' В линейных системах  '],
[' Что находится при решении уравнения Беллмана?  ', ' Самые короткие расстояния  ', ' Самые длинные расстояния  ', ' Циклы без циклов  ', ' Отрицательные направления  ', ' Параллельные точки соединения  '],
[' Какой алгоритм можно использовать для графа с отрицательными длинами направлений?  ', ' Алгоритм Беллмана-Форда  ', ' Метод Дейкстры  ', ' Метод бесконечных циклов  ', ' Алгоритм Флойда-Уоршелла  ', ' Параллельный метод  '],
[' С какой сложностью работает алгоритм Флойда-Уоршелла?  ', ' O(n^3)  ', ' O(n^2)  ', ' O(log n)  ', ' O(nm)  ', ' O(IAI + n log n)  '],
[' Какой алгоритм более подходит для разреженных графов?  ', ' Алгоритм Беллмана-Форда  ', ' Алгоритм Флойда-Уоршелла  ', ' Матрицы методов  ', ' Параллельные алгоритмы  ', ' Методы с замкнутыми циклами  '],
[' Сколько итераций нужно для решения уравнения Беллмана?  ', ' m+1 итераций  ', ' Одна итерация  ', ' Бесконечная итерация  ', ' Параллельная итерация  ', ' Итерация без циклов  '],
[' В каких графах алгоритм Беллмана-Форда работает быстрее?  ', ' В разреженных графах  ', ' В плотных графах  ', ' В графах без циклов  ', ' В параллельных графах  ', ' В динамических графах  '],
[' Как работает алгоритм Беллмана-Форда для графа с отрицательными циклами?  ', ' Убирая положительные циклы  ', ' Находя отрицательный цикл  ', ' Решая отрицательные циклы двойной итерацией  ', ' Не давая никакого решения  ', ' Решая параллельно  '],
[' Для каких графов метод Дейкстры не подходит?  ', ' Для графов с отрицательными длинами направлений  ', ' Для графов с ненегативными длинами направлений  ', ' Для графов без циклов  ', ' Для динамических графов  ', ' Для параллельно работающих графов  '],
[' Какое преимущество алгоритма Беллмана-Форда?  ', ' Возможность решать задачи с отрицательными длинами направлений  ', ' Возможность вычислять максимальные циклы  ', ' Работа с бесконечными итерациями  ', ' Последовательная проверка вершин  ', ' Приведение циклов к бесконечности  '],
[' От чего зависит количество итераций для решения уравнения Беллмана?  ', ' От пути, содержащего наименьшее количество направлений  ', ' От размера графа  ', ' От количества циклов  ', ' От количества процессоров  ', ' От количества динамических процессоров  '],
[' С какими типами процессоров работает алгоритм Беллмана-Форда?  ', ' С параллельными процессорами  ', ' С одноядерными процессорами  ', ' С циклическими процессорами  ', ' С аналоговыми процессорами  ', ' С матричными процессорами  '],
[' Что обеспечивает предположение о связности графа?  ', ' Наличие пути от каждой вершины до целевой точки  ', ' Снижение количества циклов  ', ' Отсутствие связи между вершинами  ', ' Нахождение отрицательных циклов  ', ' Соединение процессоров  '],
[' Для каких графов алгоритм Флойда-Уоршелла более подходит?  ', ' Для плотных графов  ', ' Для разреженных графов  ', ' Для графов с ненегативными длинами направлений  ', ' Для графов с бесконечными циклами  ', ' Для графов с отрицательными направлениями  '],
[' Как находится длина самого короткого пути?  ', ' Суммой длин направлений  ', ' Максимальным расстоянием  ', ' Количеством циклов  ', ' Количеством вершин  ', ' Скалярным множителем  '],
[' В каких случаях алгоритм Беллмана-Форда производит итерации?  ', ' Пока расстояния для всех вершин не станут неизменными  ', ' Когда достигнута целевая точка  ', ' Когда найден отрицательный цикл  ', ' При наличии бесконечных циклов  ', ' Когда процессор загружен  '],
[' Когда алгоритм Флойда-Уоршелла становится более эффективным?  ', ' Для плотных графов  ', ' Для разреженных графов  ', ' Когда есть отрицательные циклы  ', ' Когда целевая точка известна  ', ' Когда есть ненегативные направления  '],
[' Для каких типов графов метод Дейкстры не подходит?  ', ' Для графов с отрицательными длинами направлений  ', ' Для графов с ненегативными длинами направлений  ', ' Для графов без циклов  ', ' Для параллельных графов  ', ' Для динамических графов  '],
[' В каких случаях алгоритм Беллмана-Форда может работать и с отрицательными направлениями?  ', ' Когда нет положительных циклов  ', ' Когда есть отрицательный цикл  ', ' Когда все направления отрицательные  ', ' Когда есть пути без циклов  ', ' Когда граф неориентированный  '],
[' Какой алгоритм используется для нахождения самого короткого пути от каждой вершины к каждой другой?  ', ' Алгоритм Флойда-Уоршелла  ', ' Алгоритм Беллмана-Форда  ', ' Алгоритм Дейкстры  ', ' Динамическое программирование  ', ' Алгоритм для неориентированного графа  '],
[' Для каких графов алгоритм Беллмана-Форда более эффективен?  ', ' Для разреженных графов  ', ' Для плотных графов  ', ' Для параллельных графов  ', ' Для графов с отрицательными циклами  ', ' Для аналоговых графов  '],
[' Как работает алгоритм Беллмана-Форда для графов с отрицательными длинами направлений?  ', ' Убирая положительные циклы  ', ' Вычисляя отрицательные циклы  ', ' Создавая бесконечные циклы  ', ' Решая параллельной итерацией  ', ' Меняя направление графа  '],
[' Каковы основные причины необходимости параллельных и распределенных вычислений?  ', ' Сократить время, необходимое для решения больших объемов численных вычислений  ', ' Увеличить скорость работы только одноядерных процессоров  ', ' Решать задачи, связанные только с обработкой изображений  ', ' Постоянно повторять одни и те же операции  ', ' Ускорить разработку программного обеспечения только  '],
[' Как классифицируются параллельные вычислительные системы?  ', ' На основе типа и количества процессоров, глобального механизма управления и синхронной/асинхронной работы  ', ' Только по скорости процессоров  ', ' По использованному программному обеспечению  ', ' Только по размеру компьютеров  ', ' По скорости передачи данных  '],
[' В чем разница между SIMD и MIMD?  ', ' SIMD управляет множеством данных одной инструкцией, а MIMD управляет различными инструкциями одновременно  ', ' SIMD работает только с одноядерными процессорами, а MIMD всегда с двумя процессорами  ', ' MIMD всегда медленнее SIMD  ', ' SIMD используется только в приложениях искусственного интеллекта  ', ' MIMD не выполняет никаких инструкций одновременно  '],
[' Что такое синхронная работа в параллельных компьютерах?  ', ' Одновременная работа процессоров с общими глобальными тактовыми импульсами  ', ' Просто случайное распределение данных  ', ' Выполнение каждым процессором различных операций в разное время  ', ' Работы всех процессоров без связи друг с другом  ', ' Синхронизация используется только для замедления передачи данных  '],
[' Для чего используется DAG (ориентированный ациклический граф)?  ', ' Для отображения последовательности операций параллельных алгоритмов и зависимостей данных  ', ' Используется только в задачах обработки изображений  ', ' Используется для измерения мощности процессоров  ', ' Для выполнения вычислений на графиках  ', ' Для проверки сетевого соединения на компьютерах  ']]


const result=[['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false'],
['true', 'false', 'false', 'false', 'false']]

let answ = image_question;
let answer_questions = result;



let incorrect_answers=[];

const questions = [];
const inputMin = document.querySelector('.min'); 
const inputMax = document.querySelector(".max");
const inputCount = document.querySelector(".input-count");
const homePage = document.querySelector('.home');
const questionPage = document.querySelector('.quiz');
const startBtn = document.querySelector("#start");



const inputElement = document.querySelector('.max');
    
inputElement.value = answ.length;
console.log(answ)

startBtn.addEventListener('click', () => {
    homePage.classList.add('hide');
    questionPage.classList.remove('hide');
    document.getElementById('question').classList.remove('hide')
    incorrect_answers=[];

    localStorage.removeItem("incorrects");
    let random_number = randomNumber();
    // console.log(random_number)
    
    questions.length = 0; // Reset questions array

    for (let k = 0; k < random_number.length; k++) {
        let i = random_number[k];
        let count = answer_questions[i].length;
        let answer = [];

        for (let j = 0; j < count; j++) {
            let copied_answers = [];
            
            for (let m = 0; m < count + 1; m++) {
                let new_answer = {};
                if (m !== j) {
                    new_answer['text'] = answ[i][m];
                    new_answer['correct'] = answer_questions[i][m-1];
                    new_answer['originalIndex'] = m-1;
                    copied_answers.push(new_answer);
                }
            }
            answer.push(copied_answers);
            copied_answers=[]
        }

        questions.push({
            question: answ[i][0],
            answers: answer[0]
        });
       
        
    }
  

    startQuiz();
});

// Initialize answer_dict if needed
// let answer_dict = Array.from({ length: count }, () => ({}));

function randomNumber() {
    let start = parseFloat(inputMin.value);
    let finish = parseFloat(inputMax.value);
    let count_question = parseFloat(inputCount.value);
    let res = [];

    while (res.length < count_question) {
        let rand = Math.floor(Math.random() * (finish - start + 1)) + start;
        if (!res.includes(rand)) {
            res.push(rand);
        }
    }

    return res;
}

// Other functions and event listeners go here...


function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

const questionElement = document.getElementById("question");
const answerButtons = document.getElementById("answer-buttons");
const nextButton = document.getElementById("next-btn");
const backButton = document.getElementById("back-btn");

let currentQuestionIndex = 0;
let score = 0;
let userAnswers = []; // Array to store user's selected answers


function startQuiz() {

    document.getElementById('incorrect').classList.add('hide')
    currentQuestionIndex = 0;
    score = 0;
    userAnswers = Array(questions.length).fill(null); // Reset user's selected answers
    nextButton.innerHTML = "Next";
    backButton.innerHTML = "Back";
    showQuestion();
}

function addImage(element, container) {
    if (element.includes('output_imagess')) {
        const image = document.createElement('img');
        image.setAttribute('src', element);
        image.classList.add('pidr');
        container.appendChild(image);
    } else {
        container.textContent = element; // Add text if it's not an image
    }
}

function removeImages() {
    // Remove images from the question and answer containers
    const images = document.querySelectorAll('.pidr');
    images.forEach(img => img.remove());
}

function showQuestion() {

    resetState();
    removeImages(); // Remove images before showing the next question


    let currentQuestion = questions[currentQuestionIndex];
    let questionNo = currentQuestionIndex + 1;

    // Clear the content of the question container
    questionElement.innerHTML = questionNo + ".  ";

    // Check if the question contains an image
    if (currentQuestion.question.includes('output_imagess')) {
        addImage(currentQuestion.question, document.getElementById('q'));
    } else {
        // If it's not an image, add the text content
        questionElement.textContent = questionNo + ".  " + currentQuestion.question;
    }

    const shuffledAnswers = shuffle([...currentQuestion.answers]);
    // const shuffledAnswers = currentQuestion.answers;
    // console.log(shuffledAnswers)


    shuffledAnswers.forEach((answer, index) => {
        const button = document.createElement("button");
        button.classList.add("btn");
        addImage(answer.text, button);
        answerButtons.appendChild(button);

        if (answer.correct) {
            button.dataset.correct = answer.correct;
        }
        button.addEventListener("click", () => selectAnswer(index, shuffledAnswers));
    });

    // If user has already answered this question, select the answer button
    const selectedAnswerOriginalIndex = userAnswers[currentQuestionIndex];
    if (selectedAnswerOriginalIndex !== null && selectedAnswerOriginalIndex !== undefined) {
        let selectedAnswer = shuffledAnswers.find(answer => answer.originalIndex === selectedAnswerOriginalIndex);
        if (selectedAnswer) {
            const selectedIndex = shuffledAnswers.indexOf(selectedAnswer);
            const selectedBtn = answerButtons.children[selectedIndex];
            selectedBtn.classList.add("selected");
            currentQuestion.answers[selectedIndex].selected = true;
        }
        
    }

    // Highlight the correct answer
    const correctAnswer = shuffledAnswers.find(answer => answer.correct);
    if (correctAnswer) {
        const correctIndex = shuffledAnswers.indexOf(correctAnswer);
        const correctBtn = answerButtons.children[correctIndex];
        correctBtn.classList.add("correct-answer");
    }
}

function resetState() {
    while (answerButtons.firstChild) {
        answerButtons.removeChild(answerButtons.firstChild);

    }
}


function selectAnswer(selectedAnswerIndex, shuffledAnswers) {
    const selectedAnswer = shuffledAnswers[selectedAnswerIndex];
    userAnswers[currentQuestionIndex] = selectedAnswer.originalIndex;
    
    const selectedBtn = answerButtons.children[selectedAnswerIndex];
    const prevSelectedBtn = answerButtons.querySelector(".selected");
    const checkbox = document.querySelector('.checkbox-inline input[type="checkbox"]');

    if (prevSelectedBtn) {
        prevSelectedBtn.classList.remove("selected");
    }
    selectedBtn.classList.add("selected");
    
    const isCorrect = selectedBtn.dataset.correct === "true";
    if (isCorrect) {
        if (checkbox.checked) {
            selectedBtn.classList.add("correct");
        }
        score++;
    } else if (checkbox.checked && !isCorrect) {
        selectedBtn.classList.add("incorrect");
    } if(!isCorrect){
        incorrect_answers.push(questions[currentQuestionIndex])
        console.log(incorrect_answers)
        
        
    }

    Array.from(answerButtons.children).forEach(button => {
        if (button.dataset.correct === "true" && checkbox.checked) {
            button.classList.add("correct");
        }
        if (checkbox.checked){
            button.disabled = true;
        }         
        
    });
    nextButton.style.display = "block";
    backButton.style.display = "block";
}

function showScore() {
    resetState();
    questionElement.innerHTML = `You scored ${score} out of ${questions.length}!`;
    nextButton.innerHTML = "Play Again";
    backButton.innerHTML='Show incorrect'
    nextButton.style.display = "block";
    localStorage.setItem("incorrects", JSON.stringify(incorrect_answers));
    // console.log(localStorage.incorrects);
    removeImages();
}

function handleNextButton() {
    currentQuestionIndex++;
    if (currentQuestionIndex < questions.length) {
        showQuestion();


    } else {
        showScore();
    }
}

function handleBackButton() {
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        showQuestion();
    }
}

nextButton.addEventListener("click", () => {
    if (currentQuestionIndex < questions.length) {
        handleNextButton();
    } else {
        startQuiz();
    }if (currentQuestionIndex===questions.length-1){
        nextButton.innerHTML = "Finish";
        
    }
});
backButton.addEventListener("click", () => {
    if (currentQuestionIndex > 0) {
        handleBackButton();
        nextButton.innerHTML = "Next";
    }if (currentQuestionIndex===questions.length-1){
        document.getElementById('incorrect').classList.remove('hide')
        document.getElementById('btn').classList.add('hide')
        showAllQuestions(incorrect_answers);
        
        
    }
});


let currentQuestionindex = 0;
const questionsContainer = document.getElementById('questions-container');
const showIncorrectAnswersButton = document.getElementById('show-incorrect-answers');


showIncorrectAnswersButton.addEventListener('click', () => {
    questionPage.classList.remove('hide');
    homePage.classList.remove('hide');
    questionsContainer.classList.add('hide')
    showIncorrectAnswersButton.classList.add('hide')
    // document.getElementById('question').classList.remove('hide')
    document.getElementById('btn').classList.remove('hide')
    questionPage.classList.add('hide')
    location.reload()
    
    startQuiz()

});


console.log(incorrect_answers)

function showAllQuestions(incorrect_answers) {

    document.getElementById('question').classList.add('hide')

    resetState();
    removeImages(); // Remove images before showing the next question

    for (let i = 0; i < incorrect_answers.length; i++) {
        currentQuestionindex = i;
        let currentQuestion = incorrect_answers[currentQuestionindex];
        let questionNo = currentQuestionindex + 1;

        // Create a container for each question
        const questionContainerElement = document.createElement('div');
        questionContainerElement.classList.add('question-container');

        // Display the question number and text
        questionContainerElement.innerHTML = questionNo + ". " + "<br>";

        // Check if the question contains an image
        if (currentQuestion.question.includes('output_imagess')) {
            addImage(currentQuestion.question, document.getElementById('questions-container'));
        } else {
            // If it's not an image, add the text content
            questionContainerElement.innerHTML = questionNo + ". " + currentQuestion.question + "<br>";
        }

        const shuffledAnswers = shuffle([...currentQuestion.answers]);

        shuffledAnswers.forEach((answer, index) => {
            const button = document.createElement("button");
            button.classList.add("btn");
            addImage(answer.text, button);
            questionContainerElement.appendChild(button);

            if (answer.correct) {
                button.dataset.correct = answer.correct;
            }

            button.addEventListener("click", () => selectAnswer(index, shuffledAnswers));
        });

        const selectedAnswerOriginalIndex = userAnswers[currentQuestionindex];
        if (selectedAnswerOriginalIndex !== null && selectedAnswerOriginalIndex !== undefined) {
            let selectedAnswer = shuffledAnswers.find(answer => answer.originalIndex === selectedAnswerOriginalIndex);
            if (selectedAnswer) {
                const selectedIndex = shuffledAnswers.indexOf(selectedAnswer);
                const selectedBtn = questionContainerElement.children[selectedIndex + 1]; // +1 to skip the question text
                selectedBtn.classList.add("incorrect");
                currentQuestion.answers[selectedIndex].selected = false;
            }
        }

        const correctAnswer = shuffledAnswers.find(answer => answer.correct);
        const correctIndex = shuffledAnswers.indexOf(correctAnswer);
        const correctBtn = questionContainerElement.children[correctIndex + 1]; // +1 to skip the question text
        correctBtn.classList.add("correct");

        // Append the question container to the main container
        questionsContainer.appendChild(questionContainerElement);
    }
}



